"""
Auto-generated FastAPI Service
Prompt: You are Code Agent, Expert AI coding assistant with file system access.

## YOUR PERSONALITY
• Precise and methodical in approach
• Writes clean, production-ready code
• Explains changes clearly and concisely
• Asks clarifying questions when requirements are ambiguous
• Focuses on best practices and maintainability
• Considers edge cases and error handling

## TECHNOLOGY STACK
• React 18 with functional components and hooks
• Vite for build tooling
• TypeScript for type safety
• Tailwind CSS with semantic tokens (bg-background, text-foreground)
• shadcn/ui components built on Radix primitives
• React Query (@tanstack/react-query) for server state
• React Router DOM v6 for routing
• Supabase for backend (PostgreSQL, Edge Functions, Auth, Storage)
• Lucide React for icons
• Framer Motion for animations

## CODING RULES (MUST FOLLOW)
1. Always use TypeScript for all code files
2. Use Tailwind CSS classes for styling - never inline styles
3. Import UI components from @/components/ui/
4. Create small, focused components (single responsibility)
5. Include proper error handling and loading states
6. Use React hooks correctly (proper dependency arrays, cleanup functions)
7. Never hardcode API keys or secrets in client code
8. Use semantic HTML elements for accessibility
9. Make components keyboard navigable with proper ARIA labels
10. Write self-documenting code with clear variable/function names
11. Add TypeScript types for all props and state
12. Use proper import paths with @ alias

## AVAILABLE TOOLS
You have access to these file system tools:

1. **create_file(path, content)** - Create a new file
   - Use for new components, pages, hooks, utilities
   - Always include all necessary imports
   
2. **edit_file(path, content?, search?, replace?)** - Modify existing file
   - Use content for complete rewrites
   - Use search/replace for targeted changes
   
3. **delete_file(path)** - Remove a file (use carefully)

4. **read_file(path)** - Read file contents
   - Always read before editing unfamiliar files
   
5. **list_files()** - List all project files

## WORKFLOW
1. Carefully understand what the user wants
2. Review relevant existing files with read_file() if needed
3. Plan your changes (minimal, focused modifications)
4. Execute using appropriate tools
5. Explain what you did in plain English

## CRITICAL RESPONSE FORMAT RULES
**NEVER include raw code in your text response!** The code goes to files via tools only.

Your text response should ONLY contain:
- A brief explanation of what you created/modified
- Why you made certain design decisions
- How to use what you built
- Any follow-up suggestions

Example good response:
"I created a TodoList component with add, delete, and toggle functionality. It uses local state to manage the todos and includes smooth animations. You can import it in any page with `import TodoList from '@/components/TodoList'`."

Example BAD response (NEVER do this):
"Here's the code: ```tsx function TodoList()... ```"

The user sees code in the code editor panel - you don't need to show it again in chat.

## CURRENT REQUEST
create for me a random architecture please
Generated: 2025-12-27T06:14:41.925651
"""

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, List, Dict
import os
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Auto-Generated API",
    description="Generated by Mother Machine",
    version="1.0.0"
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Health check
@app.get("/health")
async def health():
    return {"status": "healthy", "timestamp": "2025-12-27T06:14:41.925661"}

# AI-Generated Code
I'll create a comprehensive FastAPI backend for a Task Management System with proper architecture. This will include all the production-ready endpoints you requested.

<create_file path="main.py" content="from fastapi import FastAPI, HTTPException, Depends, status, Query
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field, validator
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from enum import Enum
import uuid
import asyncio

app = FastAPI(
    title="Task Management API",
    description="Production-ready task management system",
    version="1.0.0"
)

# CORS Configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://yourdomain.com"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Security
security = HTTPBearer()

# Enums
class TaskStatus(str, Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    CANCELLED = "cancelled"

class TaskPriority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"

class UserRole(str, Enum):
    ADMIN = "admin"
    MANAGER = "manager"
    USER = "user"

# Pydantic Models
class UserCreate(BaseModel):
    email: str = Field(..., regex=r'^[^@]+@[^@]+\.[^@]+$')
    username: str = Field(..., min_length=3, max_length=50)
    password: str = Field(..., min_length=8)
    full_name: str = Field(..., min_length=1, max_length=100)
    role: UserRole = UserRole.USER

class UserResponse(BaseModel):
    id: str
    email: str
    username: str
    full_name: str
    role: UserRole
    created_at: datetime
    is_active: bool

class TaskCreate(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    priority: TaskPriority = TaskPriority.MEDIUM
    due_date: Optional[datetime] = None
    assigned_to: Optional[str] = None
    tags: List[str] = Field(default_factory=list, max_items=10)
    
    @validator('due_date')
    def validate_due_date(cls, v):
        if v and v < datetime.utcnow():
            raise ValueError('Due date cannot be in the past')
        return v

class TaskUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    status: Optional[TaskStatus] = None
    priority: Optional[TaskPriority] = None
    due_date: Optional[datetime] = None
    assigned_to: Optional[str] = None
    tags: Optional[List[str]] = Field(None, max_items=10)

class TaskResponse(BaseModel):
    id: str
    title: str
    description: Optional[str]
    status: TaskStatus
    priority: TaskPriority
    created_at: datetime
    updated_at: datetime
    due_date: Optional[datetime]
    assigned_to: Optional[str]
    created_by: str
    tags: List[str]
    completion_percentage: int

class ProjectCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    start_date: datetime
    end_date: Optional[datetime] = None
    team_members: List[str] = Field(default_factory=list)
    
    @validator('end_date')
    def validate_end_date(cls, v, values):
        if v and 'start_date' in values and v <= values['start_date']:
            raise ValueError('End date must be after start date')
        return v

class ProjectResponse(BaseModel):
    id: str
    name: str
    description: Optional[str]
    start_date: datetime
    end_date: Optional[datetime]
    created_at: datetime
    team_members: List[str]
    task_count: int
    completion_percentage: int

class HealthResponse(BaseModel):
    status: str
    timestamp: datetime
    version: str
    uptime: str

# Mock database (replace with real database in production)
users_db = {}
tasks_db = {}
projects_db = {}

# Dependency functions
async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """
    Extract and validate user from JWT token.
    In production, implement proper JWT validation.
    """
    # Mock implementation - replace with real JWT validation
    token = credentials.credentials
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Mock user - replace with actual token validation
    return {"id": "user123", "username": "testuser", "role": UserRole.USER}

async def get_admin_user(current_user: dict = Depends(get_current_user)):
    """Ensure current user has admin privileges."""
    if current_user.get("role") != UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin access required"
        )
    return current_user

# Health Check Endpoint
@app.get("/health", response_model=HealthResponse, tags=["Health"])
async def health_check():
    """
    Health check endpoint for monitoring and load balancer.
    Returns system status and basic metrics.
    """
    return HealthResponse(
        status="healthy",
        timestamp=datetime.utcnow(),
        version="1.0.0",
        uptime="24h 15m 30s"
    )

# User Management Endpoints
@app.post("/users", response_model=UserResponse, status_code=status.HTTP_201_CREATED, tags=["Users"])
async def create_user(user_data: UserCreate):
    """
    Create a new user account.
    Validates email uniqueness and password strength.
    """
    try:
        # Check if user already exists
        for existing_user in users_db.values():
            if existing_user.get("email") == user_data.email:
                raise HTTPException(
                    status_code=status.HTTP_409_CONFLICT,
                    detail="User with this email already exists"
                )
        
        user_id = str(uuid.uuid4())
        new_user = {
            "id": user_id,
            "email": user_data.email,
            "username": user_data.username,
            "full_name": user_data.full_name,
            "role": user_data.role,
            "created_at": datetime.utcnow(),
            "is_active": True,
            "password_hash": f"hashed_{user_data.password}"  # Hash in production
        }
        
        users_db[user_id] = new_user
        
        return UserResponse(**new_user)
    
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create user"
        )

@app.get("/users", response_model=List[UserResponse], tags=["Users"])
async def list_users(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
    current_user: dict = Depends(get_admin_user)
):
    """
    Get paginated list of all users.
    Requires admin privileges.
    """
    users_list = list(users_db.values())[skip:skip + limit]
    return [UserResponse(**user) for user in users_list]

@app.get("/users/{user_id}", response_model=UserResponse, tags=["Users"])
async def get_user(user_id: str, current_user: dict = Depends(get_current_user)):
    """
    Get user details by ID.
    Users can only access their own data unless they're admin.
    """
    if user_id not in users_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    # Check permissions
    if current_user["id"] != user_id and current_user.get("role") != UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )
    
    return UserResponse(**users_db[user_id])

# Task Management Endpoints
@app.post("/tasks", response_model=TaskResponse, status_code=status.HTTP_201_CREATED, tags=["Tasks"])
async def create_task(task_data: TaskCreate, current_user: dict = Depends(get_current_user)):
    """
    Create a new task.
    Task is automatically assigned to the creator unless specified otherwise.
    """
    try:
        task_id = str(uuid.uuid4())
        new_task = {
            "id": task_id,
            "title": task_data.title,
            "description": task_data.description,
            "status": TaskStatus.PENDING,
            "priority": task_data.priority,
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(),
            "due_date": task_data.due_date,
            "assigned_to": task_data.assigned_to or current_user["id"],
            "created_by": current_user["id"],
            "tags": task_data.tags,
            "completion_percentage": 0
        }
        
        tasks_db[task_id] = new_task
        
        return TaskResponse(**new_task)
    
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create task"
        )

@app.get("/tasks", response_model=List[TaskResponse], tags=["Tasks"])
async def list_tasks(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
    status_filter: Optional[TaskStatus] = Query(None),
    priority_filter: Optional[TaskPriority] = Query(None),
    assigned_to: Optional[str] = Query(None),
    current_user: dict = Depends(get_current_user)
):
    """
    Get paginated list of tasks with optional filters.
    Users see only their assigned tasks unless they're admin.
    """
    filtered_tasks = []
    
    for task in tasks_db.values():
        # Permission check
        if (current_user.get("role") != UserRole.ADMIN and 
            task["assigned_to"] != current_user["id"] and 
            task["created_by"] != current_user["id"]):
            continue
            
        # Apply filters
        if status_filter and task["status"] != status_filter:
            continue
        if priority_filter and task["priority"] != priority_filter:
            continue
        if assigned_to and task["assigned_to"] != assigned_to:
            continue
            
        filtered_tasks.append(task)
    
    paginated_tasks = filtered_tasks[skip:skip + limit]
    return [TaskResponse(**task) for task in paginated_tasks]

@app.get("/tasks/{task_id}", response_model=TaskResponse, tags=["Tasks"])
async def get_task(task_id: str, current_user: dict = Depends(get_current_user)):
    """
    Get task details by ID.
    Users can only access tasks they created or are assigned to.
    """
    if task_id not in tasks_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Task not found"
        )
    
    task = tasks_db[task_id]
    
    # Permission check
    if (current_user.get("role") != UserRole.ADMIN and 
        task["assigned_to"] != current_user["id"] and 
        task["created_by"] != current_user["id"]):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )
    
    return TaskResponse(**task)

@app.put("/tasks/{task_id}", response_model=TaskResponse, tags=["Tasks"])
async def update_task(
    task_id: str, 
    task_update: TaskUpdate, 
    current_user: dict = Depends(get_current_user)
):
    """
    Update task details.
    Only task creator, assignee, or admin can update.
    """
    if task_id not in tasks_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Task not found"
        )
    
    task = tasks_db[task_id]
    
    # Permission check
    if (current_user.get("role") != UserRole.ADMIN and 
        task["assigned_to"] != current_user["id"] and 
        task["created_by"] != current_user["id"]):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )
    
    # Update fields
    update_data = task_update.dict(exclude_unset=True)
    for field, value in update_data.items():
        task[field] = value
    
    task["updated_at"] = datetime.utcnow()
    
    # Auto-calculate completion percentage based on status
    if task["status"] == TaskStatus.COMPLETED:
        task["completion_percentage"] = 100
    elif task["status"] == TaskStatus.IN_PROGRESS:
        task["completion_percentage"] = max(task["completion_percentage"], 25)
    
    return TaskResponse(**task)

@app.delete("/tasks/{task_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Tasks"])
async def delete_task(task_id: str, current_user: dict = Depends(get_current_user)):
    """
    Delete a task.
    Only task creator or admin can delete.
    """
    if task_id not in tasks_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Task not found"
        )
    
    task = tasks_db[task_id]
    
    # Permission check
    if (current_user.get("role") != UserRole.ADMIN and 
        task["created_by"] != current_user["id"]):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only task creator or admin can delete tasks"
        )
    
    del tasks_db[task_id]

# Project Management Endpoints
@app.post("/projects", response_model=ProjectResponse, status_code=status.HTTP_201_CREATED, tags=["Projects"])
async def create_project(project_data: ProjectCreate, current_user: dict = Depends(get_current_user)):
    """
    Create a new project.
    Only managers and admins can create projects.
    """
    if current_user.get("role") not in [UserRole.ADMIN, UserRole.MANAGER]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Manager

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", 8000))
    uvicorn.run(app, host="0.0.0.0", port=port)
